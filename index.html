<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Garbage Can Regression Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Garbage Can Regression Challenge</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="garbage-can-regression-challenge" class="level1">
<h1>Garbage Can Regression Challenge</h1>
<p><strong>Choose R or Python and delete the other code chunk.</strong></p>
<section id="r-code" class="level2">
<h2 class="anchored" data-anchor-id="r-code">R Code</h2>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.4
✔ forcats   1.0.0     ✔ stringr   1.5.0
✔ ggplot2   3.4.3     ✔ tibble    3.2.1
✔ lubridate 1.9.2     ✔ tidyr     1.3.0
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 15 × 4
   Stress StressSurvey  Time Anxiety
    &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
 1      0            0   0      0   
 2      0            0   1      0.1 
 3      0            0   1      0.1 
 4      1            3   1      1.1 
 5      1            3   1      1.1 
 6      1            3   1      1.1 
 7      2            6   2      2.2 
 8      2            6   2      2.2 
 9      2            6   2      2.2 
10      8            9   2      8.2 
11      8            9   2      8.2 
12      8            9   2.1    8.21
13     12           12   2.2   12.2 
14     12           12   2.2   12.2 
15     12           12   2.2   12.2 </code></pre>
</div>
</div>
</section>
<section id="your-analysis" class="level2">
<h2 class="anchored" data-anchor-id="your-analysis">Your Analysis</h2>
<p>Follow the challenge instructions from your course to complete your analysis. Questions to Answer for 75% Grade on Challenge:</p>
<ol type="1">
<li>Bivariate regression Analysis with StressSurvey: Run a bivariate regression of Anxiety on StressSurvey. What are the estimated coefficients? How do they compare to the true relationship?</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = Anxiety ~ StressSurvey, data = observDF)

Residuals:
   Min     1Q Median     3Q    Max 
-2.558 -0.517  0.301  1.180  1.624 

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)   -1.5240     0.7069  -2.156   0.0504 .  
StressSurvey   1.0470     0.0962  10.883 6.68e-08 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.581 on 13 degrees of freedom
Multiple R-squared:  0.9011,    Adjusted R-squared:  0.8935 
F-statistic: 118.4 on 1 and 13 DF,  p-value: 6.681e-08</code></pre>
</div>
</div>
<p>The estimated coefficient for StressSurvey is 1.047, which is close to the true relationship of 1.</p>
<ol start="2" type="1">
<li>Visualization of Bivariate Relationship: Create a scatter plot with the regression line showing the relationship between StressSurvey and Anxiety. Comment on the fit and any potential issues.</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>`geom_smooth()` using formula = 'y ~ x'</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/plot-anxiety-vs-stresssurvey-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "/"</code></pre>
</div>
</div>
<p>The regression seems to follow to overall pattern of the points but leave out some outliers.</p>
<ol start="3" type="1">
<li>Bivariate Regression Analysis with Time: Run a bivariate regression of Anxiety on Time. What are the estimated coefficients? How do they compare to the true relationship?</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = Anxiety ~ Time, data = observDF)

Residuals:
    Min      1Q  Median      3Q     Max 
-4.8010 -1.5605 -0.5605  2.4395  4.1508 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)   
(Intercept)   -3.680      2.233  -1.648  0.12330   
Time           5.341      1.305   4.093  0.00127 **
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.323 on 13 degrees of freedom
Multiple R-squared:  0.563, Adjusted R-squared:  0.5294 
F-statistic: 16.75 on 1 and 13 DF,  p-value: 0.00127</code></pre>
</div>
</div>
<p>The estimated coefficient for Time is 5.341, which is far off from the true relationship of 0.1.</p>
<ol start="4" type="1">
<li>Visualization of Bivariate Relationship: Create a scatter plot with the regression line showing the relationship between Time and Anxiety. Comment on the fit and any potential issues.</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>`geom_smooth()` using formula = 'y ~ x'</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/plot-anxiety-vs-time-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "/"</code></pre>
</div>
</div>
<p>The regression seems to follow to overall pattern of the points but leaves out some outliers. The gray area shows the confidence interval range with 95% confidence. The graph with anxiety and time seems to have a larger area of confidence compared to stress survey meaning that it isn’t as confident in predicting anxiety as the first graph was.</p>
<ol start="5" type="1">
<li>Multiple Regression Analysis: Run a multiple regression of Anxiety on both StressSurvey and Time. What are the estimated coefficients? How do they compare to the true relationship?</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = Anxiety ~ StressSurvey + Time, data = observDF)

Residuals:
    Min      1Q  Median      3Q     Max 
-1.3904 -0.9896  0.3288  0.6240  2.2912 

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)    0.5888     1.0339   0.569   0.5795    
StressSurvey   1.4269     0.1722   8.287 2.62e-06 ***
Time          -2.7799     1.1111  -2.502   0.0278 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.334 on 12 degrees of freedom
Multiple R-squared:  0.935, Adjusted R-squared:  0.9242 
F-statistic: 86.32 on 2 and 12 DF,  p-value: 7.538e-08</code></pre>
</div>
</div>
<p>The estimated coefficient for StressSurvey is 1.4269, which is 0.4 off from the true relationship of 1. The estimated coefficient for Time is -2.7799, which is far off from the true relationship of 0.1.</p>
<p>Questions to Answer for 85% Grade on Challenge:</p>
<ol start="6" type="1">
<li>Multiple Regression Analysis: Run a multiple regression of Anxiety on both Stress and Time. What are the estimated coefficients? How do they compare to the true relationship?</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Warning in summary.lm(model): essentially perfect fit: summary may be
unreliable</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = Anxiety ~ Stress + Time, data = observDF)

Residuals:
       Min         1Q     Median         3Q        Max 
-1.330e-15 -4.027e-16  2.604e-16  4.822e-16  8.124e-16 

Coefficients:
             Estimate Std. Error   t value Pr(&gt;|t|)    
(Intercept) 9.173e-16  5.371e-16 1.708e+00    0.113    
Stress      1.000e+00  6.067e-17 1.648e+16   &lt;2e-16 ***
Time        1.000e-01  4.273e-16 2.340e+14   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 7.268e-16 on 12 degrees of freedom
Multiple R-squared:      1, Adjusted R-squared:      1 
F-statistic: 3.109e+32 on 2 and 12 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>The estimated coefficient for Stress is 1, which is the exact value of the true relationship. The estimated coefficient for Time is 0.1, which is the exact value of the true relationship.</p>
<ol start="7" type="1">
<li>Model Comparison: Compare the R-squared values and coefficient interpretations between the two multiple regression models. Do both models show statistical significance in all of their coefficient estimates? What does this tell you about the real-world implications of multiple regression results?</li>
</ol>
<p>R-squared values:</p>
<p>For StressSurvey + Time: 0.935 For Stress + Time: 1.0</p>
<p>Coefficient values:</p>
<p>For StressSurvey + Time: 1.4269, -2.7799 For Stress + Time: 1, 0.1</p>
<p>P-Value:</p>
<p>For StressSurvey + Time: 7.538e-08 For Stress + Time: 2.2 e-16</p>
<p>The model with Stress + Time has an R-squared value of 1, meaning that the model is a perfect fit. This is quite suspicious, since no model is a perfect fit. Stress + Time also has a coefficient value equal to the true relationship, which goes in line with the 1.0 R-squared value. This leads me to believe that the model with Stress + Time is unreliable because it is “too good ot be true”. In addition, both models show statistical significance in all of thier coefficient estimates since the p-value for both models is less than .05.</p>
<p>Questions to Answer for 95% Grade on Challenge:</p>
<ol start="8" type="1">
<li>Reflect on Real-World Implications: For each of the two multiple regression models, assume their rrespective outputs/conclusions were published in academic journals and then subsequently picked up by the popular press. What headline about time spent on social media and its effect on anxiety would you expect to see from a popular press outlet covering the second model? Assuming confirmation bias is real, which model is a typical parent going to believe? Which model will Facebook, Instagram, and TikTok executives prefer?</li>
</ol>
<p>I would expect to see from the popular press a title similar to: “Research Shows That Time on Social Media Has a Direct Relationship with Anxiety and Stress!” Or even claiming that stress + time on social media causes anxiety.</p>
<p>Assuming confirmation bias is real, a typical parent is going to believe the second model since a typical parents already has a stigma on social media being bad.</p>
<p>Facebook, Instagram, and TikTok executives prefer the first multiple regression model since it shows that time on social media actually decreases anxiety, because the model had a negative estimated coefficient for time.</p>
<p>Questions to Answer for 100% Grade on Challenge:</p>
<ol start="9" type="1">
<li>Avoiding Misleading Statistical Significance: Reflect on this tip to avoid being misled by statistically significant results: splitting the sample into meaningful subsets (“statistical regimes”), and using graphical diagnostics for linearity rather than blind reliance on “canned” regressions. Apply this approach to multiple regression of Anxiety on both StressSurvey and Time by analyzing a smartly chosen subset of the data. What specific subset did you choose and why? Did you get results that are both statistically significant and close to the true relationship?</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Low Stress group (&lt;= median) summary:</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in summary.lm(model_low_stress): essentially perfect fit: summary may
be unreliable</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = Anxiety ~ StressSurvey + Time, data = low_stress_df)

Residuals:
       Min         1Q     Median         3Q        Max 
-1.253e-16 -1.667e-17  8.333e-18  8.333e-18  1.253e-16 

Coefficients:
              Estimate Std. Error   t value Pr(&gt;|t|)    
(Intercept)  3.701e-17  5.871e-17 6.300e-01    0.552    
StressSurvey 3.333e-01  2.021e-17 1.649e+16   &lt;2e-16 ***
Time         1.000e-01  7.877e-17 1.270e+15   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 7.426e-17 on 6 degrees of freedom
Multiple R-squared:      1, Adjusted R-squared:      1 
F-statistic: 6.198e+32 on 2 and 6 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
High Stress group (&gt; median) summary:</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in summary.lm(model_high_stress): essentially perfect fit: summary may
be unreliable</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = Anxiety ~ StressSurvey + Time, data = high_stress_df)

Residuals:
         1          2          3          4          5          6 
 9.341e-16 -9.341e-16 -9.910e-30 -2.956e-31 -2.956e-31 -2.956e-31 

Coefficients:
               Estimate Std. Error    t value Pr(&gt;|t|)    
(Intercept)  -4.000e+00  1.449e-14 -2.760e+14   &lt;2e-16 ***
StressSurvey  1.333e+00  5.589e-16  2.385e+15   &lt;2e-16 ***
Time          1.000e-01  9.341e-15  1.071e+13   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 7.627e-16 on 3 degrees of freedom
Multiple R-squared:      1, Adjusted R-squared:      1 
F-statistic: 2.08e+31 on 2 and 3 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in summary.lm(x): essentially perfect fit: summary may be unreliable</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in summary.lm(x): essentially perfect fit: summary may be unreliable

Warning in summary.lm(x): essentially perfect fit: summary may be unreliable

Warning in summary.lm(x): essentially perfect fit: summary may be unreliable</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 7
  group              r.squared adj.r.squared    sigma    df df.residual  p.value
  &lt;chr&gt;                  &lt;dbl&gt;         &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;       &lt;int&gt;    &lt;dbl&gt;
1 Low Stress (&lt;= me…         1             1 7.43e-17     2           6 1.13e-97
2 High Stress (&gt; me…         1             1 7.63e-16     2           3 1.94e-47</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in summary.lm(x): essentially perfect fit: summary may be unreliable

Warning in summary.lm(x): essentially perfect fit: summary may be unreliable</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 6
  group                  term          estimate std.error statistic  p.value
  &lt;chr&gt;                  &lt;chr&gt;            &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
1 Low Stress (&lt;= median) (Intercept)   3.70e-17  5.87e-17  6.30e- 1 5.52e- 1
2 Low Stress (&lt;= median) StressSurvey  3.33e- 1  2.02e-17  1.65e+16 3.35e-96
3 Low Stress (&lt;= median) Time          1   e- 1  7.88e-17  1.27e+15 1.61e-89
4 High Stress (&gt; median) (Intercept)  -4.00e+ 0  1.45e-14 -2.76e+14 1.05e-43
5 High Stress (&gt; median) StressSurvey  1.33e+ 0  5.59e-16  2.39e+15 1.62e-46
6 High Stress (&gt; median) Time          1.00e- 1  9.34e-15  1.07e+13 1.80e-39</code></pre>
</div>
</div>
<p>The subset that I chose was splitting stress into two catergories: low and high stress using the median as the divider. I chose this because I felt like it would give a more accurate model and “balance” the results. Time in relation with low and high stress were the same as before with having the same estimate as the true relationship. However, the relationship with Stresssurvey with low and high stress changed slightly. In addition, the results all had lower than .05 p-value making them all statistically significant.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>